{"name":"Modula-2","aliases":[],"wiki":"http:\/\/en.wikipedia.org\/wiki\/Modula-2","description":["Modula-2 is a computer programming language designed and developed between 1977 and 1980 by Niklaus Wirth at ETH Zurich as a revision of Pascal to serve as the sole programming language for the operating system and application software for the personal workstation Lilith. The principal concepts were:","Modula-2 was understood by Niklaus Wirth as a successor to his earlier programming language Pascal. The language design was also influenced by the Mesa programming language and the new programming possibilities of the early personal computer Xerox Alto, both from Xerox, that Wirth saw during his 1976 sabbatical year at Xerox PARC.","Modula-2 is a general purpose procedural language, sufficiently flexible to do systems programming, but with much broader application. In particular, it was designed to support separate compilation and data abstraction in a straightforward way. Much of the syntax is based on Wirth's earlier and better-known language, Pascal. Modula-2 was designed to be broadly similar to Pascal, with some elements and syntactic ambiguities removed and the important addition of the module concept, and direct language support for multiprogramming.","Here is an example of the source code for the \"Hello world\" program:","\nThe Modula-2 module may be used to encapsulate a set of related subprograms and data structures, and restrict their visibility from other portions of the program. The module design implemented the data abstraction feature of Modula-2 in a very clean way. Modula-2 programs are composed of modules, each of which is made up of two parts: a definition module, the interface portion, which contains only those parts of the subsystem that are exported (visible to other modules), and an implementation module, which contains the working code that is internal to the module.","The language has strict scope control. In particular the scope of a module can be considered as an impenetrable wall: Except for standard identifiers no object from the outer world is visible inside a module unless explicitly imported; no internal module object is visible from the outside unless explicitly exported.","Suppose module M1 exports objects a, b, c, and P by enumerating its identifiers in an explicit export list","Then the objects a, b,c, and P from module M1 become now known outside module M1 as M1.a, M1.b, M1.c, and M1.P. They are exported in a qualified manner to the universe (assumed module M1 is global). The exporting module's name, i.e. M1, is used as a qualifier followed by the object's name.","Suppose module M2 contains the following IMPORT declaration","Then this means that the objects exported by module M1 to the universe of its enclosing program can now be used inside module M2. They are referenced in a qualified manner like this: M1.a, M1.b, M1.c, and M1.P. Example:","Qualified export avoids name clashes: For instance, if another module M3 would also export an object called P, then we can still distinguish the two objects, since M1.P differs from M3.P. Thanks to the qualified export it does not matter that both objects are called P inside their exporting modules M1 and M3.","There is an alternative technique available, which is in wide use by Modula-2 programmers. Suppose module M4 is formulated as this","Then this means that objects exported by module M1 to the universe can again be used inside module M4, but now by mere references to the exported identifiers in an \"unqualified\" manner like this: a, b, c, and P. Example:","This technique of unqualifying import allows use of variables and other objects outside their exporting module in exactly the same simple, i.e. unqualified, manner as inside the exporting module. The walls surrounding all modules have now become irrelevant for all those objects for which this has been explicitly allowed. Of course unqualifying import is only usable if there are no name clashes.","These export and import rules may seem unnecessarily restrictive and verbose. But they do not only safeguard objects against unwanted access, but also have the pleasant side-effect of providing automatic cross-referencing of the definition of every identifier in a program: if the identifier is qualified by a module name, then the definition comes from that module. Otherwise if it occurs unqualified, simply search backwards, and you will either encounter a declaration of that identifier, or its occurrence in an IMPORT statement which names the module it comes from. This property becomes very useful when trying to understand large programs containing many modules.","The language provides for (limited) single-processor concurrency (monitors, coroutines and explicit transfer of control) and for hardware access (absolute addresses, bit manipulation, and interrupts). It uses name equivalence.","There are two major dialects of Modula-2. The first is PIM, named after the book \"Programming in Modula-2\" by Niklaus Wirth. There were three major editions of PIM, the second, third (corrected) and fourth editions, each describing slight variants of the language. The second major dialect is ISO, from the standardization effort by the International Organization for Standardization.","There are several supersets of Modula-2 with language extensions for specific application domains:","There are several derivative languages that resemble Modula-2 very closely but are new languages in their own right. Most are different languages with different purposes and with strengths and weaknesses of their own:","Many other current programming languages have adopted features of Modula-2.","A new non-ISO standardisation effort is mentioned on the official ISO Modula-2 web site, referring to Modula-2 R10, a 2010 revision of the language based on classic Modula-2 which has its own web site from where its specification can be downloaded.","PIM [2,3,4] defines the following 40 reserved words:","PIM [3,4] defines the following 29 pervasive (built-in) identifiers:","Cambridge Modula-2 by Cambridge Microprocessor Systems is based on a subset of PIM4 with language extensions for embedded development. The compiler runs on MS-DOS and it generates code for M68K based embedded microcontrollers running the MINOS operating system.","Mod51 by Mandeno Granville Electronics is based on ISO Modula-2 with language extensions for embedded development following IEC1131, an industry standard for programmable logic controllers (PLC) closely related to Modula-2. The Mod51 compiler generates standalone code for 80C51 based microcontrollers.","Delco Electronics, then a subsidiary of GM Hughes Electronics, developed a version of Modula-2 for embedded control systems starting in 1985. Delco named it Modula-GM. It was the first high level language used to replace machine language code for embedded systems in Delco's engine control units (ECUs). This was significant because Delco was producing over 28,000 ECUs per day in 1988 for GM; this was then the world's largest producer of ECUs. The first experimental use of Modula-GM in an embedded controller was in the 1985 Antilock Braking System Controller which was based on the Motorola 68xxx microprocessor, and in 1993 Gen-4 ECU used by the CART (Championship Auto Racing Teams) and IRL (Indy Racing League) teams. The first production use of Modula-GM was its use in GM trucks starting with the 1990 model year VCM (Vehicle Control Module) used to manage GM Powertrain's Vortec engines. Modula-GM was also used on all ECUs for GM's 90\u00b0 Buick V6 family 3800 Series II used in the 1997-2005 model year Buick Park Avenue. The Modula-GM compilers and associated software management tools were sourced by Delco from Intermetrics.","Modula-2 was selected as the basis for Delco's high level language because of its many strengths over other alternative language choices in 1986. After Delco Electronics was spun off from GM (with other component divisions) to form Delphi in 1997, global sourcing required that a non-proprietary high-level software language be used. ECU embedded software now developed at Delphi is compiled with commercial C compilers.","Source for all entries: Modula2.net","This article is based on material taken from the Free On-line Dictionary of Computing prior to 1 November 2008 and incorporated under the \"relicensing\" terms of the GFDL, version 1.3 or later."]}